#!/usr/bin/env node

/**
 * Final MCP Server - HTTP Compatible with Claude.ai
 * Based on working n8n-MCP patterns
 */

const express = require('express');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3000;

// CORS for Claude.ai
app.use(cors({
  origin: true,
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept']
}));

app.use(express.json({ limit: '10mb' }));

// Server info
const serverInfo = {
  name: "Home Assistant & N8N Gateway",
  version: "1.0.0"
};

// Home Assistant adapter
const HomeAssistantAdapter = {
  async getStates(params = {}) {
    const url = params.entity_id 
      ? `https://ha.right-api.com/api/states/${params.entity_id}`
      : 'https://ha.right-api.com/api/states';
    
    const response = await fetch(url, {
      headers: { 
        'Authorization': `Bearer ${process.env.HOME_ASSISTANT_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    return await response.json();
  },

  async callService(params) {
    const { domain, service, entity_id, ...data } = params;
    const response = await fetch(`https://ha.right-api.com/api/services/${domain}/${service}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.HOME_ASSISTANT_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        entity_id,
        ...data
      })
    });
    return await response.json();
  },

  async getEntities(params = {}) {
    const states = await this.getStates();
    if (params.domain) {
      return states.filter(state => state.entity_id.startsWith(params.domain + '.'));
    }
    return states;
  }
};

// N8N adapter
const N8NAdapter = {
  async listWorkflows(params = {}) {
    const response = await fetch('https://app.right-api.com/api/v1/workflows', {
      headers: {
        'X-N8N-API-KEY': process.env.N8N_API_KEY,
        'Content-Type': 'application/json'
      }
    });
    const data = await response.json();
    if (params.active !== undefined) {
      return data.data.filter(w => w.active === params.active);
    }
    return data.data;
  },

  async executeWorkflow(params) {
    const { workflowId, data = {} } = params;
    const response = await fetch(`https://app.right-api.com/api/v1/workflows/${workflowId}/execute`, {
      method: 'POST',
      headers: {
        'X-N8N-API-KEY': process.env.N8N_API_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });
    return await response.json();
  },

  async getExecutions(params = {}) {
    const { workflowId, limit = 20 } = params;
    const url = workflowId 
      ? `https://app.right-api.com/api/v1/executions?workflowId=${workflowId}&limit=${limit}`
      : `https://app.right-api.com/api/v1/executions?limit=${limit}`;
    
    const response = await fetch(url, {
      headers: {
        'X-N8N-API-KEY': process.env.N8N_API_KEY,
        'Content-Type': 'application/json'
      }
    });
    return await response.json();
  }
};

// Tools definition
const tools = [
  {
    name: 'get_states',
    description: 'Get Home Assistant entity states',
    inputSchema: {
      type: 'object',
      properties: {
        entity_id: { type: 'string', description: 'Specific entity ID (optional)' }
      }
    }
  },
  {
    name: 'call_service', 
    description: 'Call a Home Assistant service',
    inputSchema: {
      type: 'object',
      properties: {
        domain: { type: 'string', description: 'Service domain (e.g., light, switch)' },
        service: { type: 'string', description: 'Service name (e.g., turn_on, turn_off)' },
        entity_id: { type: 'string', description: 'Target entity ID' },
        data: { type: 'object', description: 'Additional service data' }
      },
      required: ['domain', 'service']
    }
  },
  {
    name: 'get_entities',
    description: 'List Home Assistant entities by domain',
    inputSchema: {
      type: 'object',
      properties: {
        domain: { type: 'string', description: 'Domain filter (e.g., light, sensor)' }
      }
    }
  },
  {
    name: 'list_workflows',
    description: 'List all N8N workflows',
    inputSchema: {
      type: 'object',
      properties: {
        active: { type: 'boolean', description: 'Filter by active status' }
      }
    }
  },
  {
    name: 'execute_workflow',
    description: 'Execute an N8N workflow',
    inputSchema: {
      type: 'object',
      properties: {
        workflowId: { type: 'string', description: 'Workflow ID to execute' },
        data: { type: 'object', description: 'Input data for workflow' }
      },
      required: ['workflowId']
    }
  },
  {
    name: 'get_executions',
    description: 'Get N8N workflow execution history',
    inputSchema: {
      type: 'object',
      properties: {
        workflowId: { type: 'string', description: 'Filter by workflow ID' },
        limit: { type: 'number', description: 'Limit results (default: 20)' }
      }
    }
  }
];

// Root endpoint - MCP server info
app.get('/', (req, res) => {
  res.json({
    name: serverInfo.name,
    version: serverInfo.version,
    description: "Universal MCP Gateway for Home Assistant & N8N",
    protocol: "mcp",
    capabilities: {
      tools: {},
      resources: false,
      prompts: false
    },
    endpoints: {
      mcp: "/",
      health: "/health"
    }
  });
});

// Health endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      homeAssistant: 'connected',
      n8n: 'connected'
    }
  });
});

// Main MCP endpoint - handles all MCP requests
app.all('/', async (req, res) => {
  if (req.method === 'GET') {
    // Already handled above
    return;
  }

  try {
    const { jsonrpc, method, params = {}, id } = req.body;

    // Handle MCP methods
    switch (method) {
      case 'initialize':
        return res.json({
          jsonrpc: '2.0',
          result: {
            protocolVersion: '2024-11-05',
            capabilities: { tools: {} },
            serverInfo
          },
          id
        });

      case 'tools/list':
        return res.json({
          jsonrpc: '2.0',
          result: { tools },
          id
        });

      case 'tools/call':
        const { name, arguments: args = {} } = params;
        let result;

        switch (name) {
          case 'get_states':
            result = await HomeAssistantAdapter.getStates(args);
            break;
          case 'call_service':
            result = await HomeAssistantAdapter.callService(args);
            break;
          case 'get_entities':
            result = await HomeAssistantAdapter.getEntities(args);
            break;
          case 'list_workflows':
            result = await N8NAdapter.listWorkflows(args);
            break;
          case 'execute_workflow':
            result = await N8NAdapter.executeWorkflow(args);
            break;
          case 'get_executions':
            result = await N8NAdapter.getExecutions(args);
            break;
          default:
            return res.json({
              jsonrpc: '2.0',
              error: { code: -32601, message: `Unknown tool: ${name}` },
              id
            });
        }

        return res.json({
          jsonrpc: '2.0',
          result: {
            content: [{
              type: 'text',
              text: JSON.stringify(result, null, 2)
            }]
          },
          id
        });

      default:
        return res.json({
          jsonrpc: '2.0',
          error: { code: -32601, message: `Method not found: ${method}` },
          id
        });
    }

  } catch (error) {
    console.error('MCP Error:', error);
    res.json({
      jsonrpc: '2.0',
      error: { code: -32603, message: error.message },
      id: req.body?.id
    });
  }
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`ðŸš€ MCP Server running on port ${PORT}`);
  console.log(`ðŸ”— Public URL: https://thirty-newsletter-posting-mention.trycloudflare.com`);
  console.log(`ðŸ“‹ Available tools: ${tools.length}`);
  console.log(`âœ… Ready for Claude.ai connection`);
});

module.exports = app;